# 서비스 규모 확장에 따른 도메인별 배포단위 분리(MSA)에 대한 트랜잭션 처리의 한계와 해결방안
---

## 개요
아래의 내용에 따라 서비스 설계 문서를 작성한다.
1. 트랜잭션 처리의 한계
   - 주요내용
   - 문제점
2. 트랜잭션 처리 한계의 해결방안
   - 주요내용
   - MSA
   - 관심사 분리
---

## 트랜잭션 처리의 한계
- 트랜잭션이란, 'DB의 상태를 변경하는 작업의 단위'이다.
- 이커머스 시스템에 `결제/Payment` 서비스가 존재하는데, 결제 서비스에서 `결제 처리`와 `외부 데이터플랫폼 API 호출`을 같이 진행(트랜잭션)한다면 분리를 고려해야 한다.

### 주요내용
- 서비스 간의 결합도와 응집도 관리는 서비스의 독립성과 확장성, 유지보수를 위해 중요하다.
- 트랜잭션의 문제는 분산 시스템에서 일어날 수 있는 대표 문제이다.

### 문제점
- 서비스 간의 결합도는 낮추고 응집도는 높여야 한다. `Payment` 서비스에서 만약 `쿠폰 사용`과 `재고 감소`와 같은 로직도 처리한다면 어떨까?
  - `쿠폰 사용`과 `재고 감소`은 Payment 도메인의 관심사가 아니지만, Coupon과 Product 도메인 모르게 변경을 처리를 하고 있다.<br>
     추후 서비스가 확장되어서 Coupon과 Payment를 따로 관리해야 한다면, 이런 설계로 인해 책임소재가 명확하지 않게 되고 확장성이 떨어지게 된다.  
  - 이러한 문제를 결합도가 높다한다.
- 트랜잭션의 범위(Scope)가 적절해야 한다. `Payment` 서비스에서의 관심사는 `결체 처리`이다. `외부 데이터플랫폼 API 호출`와 같이 다른 관심사가 같은 트랜잭션에 묶여 있다면 어떻게 될까?
  - `외부 데이터플랫폼 API 호출`가 실패하면 `결제 처리`가 완료되었지만, 같은 트랜잭션에 묶여 있기 때문에 작업이 실패하게 된다.
  - 한 트랜잭션에 많은 작업이 처리되면 성능이 저하되고 잦은 실행으로 사이드 이펙트가 발생할 수 있다.
---

## 트랜잭션 처리 한계의 해결방안
- 서비스의 규모가 확장되면, 분산 시스템(도메인별 배포단위 분리)을 통해 각 도메인의 책임과 관심사를 분리해야 한다.
- 분산 시스템을 구성하기 위해 MSA와 같은 아키텍처를 고려하고, 트랜잭션 처리 한계를 해결하기 위해 관심사 분리 작업을 수행한다.

### 주요내용
- MSA(MicroService Architecture)를 통해 분산 시스템을 구성한다.
- 애플리케이션 이벤트와 분산 트랜잭션 관리 패턴을 통해 관심사를 분리한다.

### MSA
- 마이크로 서비스는 작고, 독립적으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크라고 할 수 있다.<br>
  또한, 완전히 독립적으로 배포가 가능하고 다른 기술 스택(개발 언어, 데이터베이스 등)이 사용 가능한 단일 사업 영역에 초점을 둔다.
- MSA는 API를 통해서만 상호작용한다. 즉, 서비스의 end-point(접근점)을 API 형태로 외부에 노출하고, 실질적인 세부 사항은 모두 추상화한다.<br>
  내부의 구현 로직, 아키텍처와 프로그래밍 언어, 데이터베이스, 품질 유지 체계와 같은 기술적인 사항들은 서비스 API에 의해 철저하게 가려진다.
- 각각의 서비스는 모듈화가 되어있고, 모듈끼리는 RPC 또는 message-driven API등을 이용하여 통신한다.<br>
  이러한 MSA는 각각 개별의 서비스 개발을 빠르게 하며, 유지보수도 쉽게할 수 있도록 한다.
  ![img1 daumcdn](https://github.com/user-attachments/assets/2622fb35-ce70-4b41-bcdb-b4915551fc82)

### 관심사 분리
- `애플리케이션 이벤트`를 통한 관심사 분리
  - EventPublisher와 EventListener
    - (Application)EventPublisher : 애플리케이션 내 이벤트를 발행하여 서비스 간 결합도를 낮춘다.
    - (Transaction)EventListener : 특정 이벤트가 발생했을 때 비동기 방식 또는 트랜잭션 경계 내에서 이벤트를 처리할 수 있도록 한다.
    - @TransactionalEventListener와 @Async를 함께 사용하는 경우, 트랜잭션 종료 후 비동기로 이벤트를 처리할 수 있어 성능과 응답 속도를 개선할 수 있다.
  - 구현 방식
    - 이벤트 발행: (Application)EventPublisher를 사용하여 비즈니스 로직에 이벤트를 발행한다.
    - 이벤트 리스너 설정: 이벤트를 구독하여 부가 기능을 작성한다.
    - 오류 및 재시도 처리: 비동기 작업에서 예외가 발생할 경우 이를 로깅하거나, 재시도 로직을 추가해야 한다.
- `Saga 분산 트랜잭션 패턴`를 통한 관심사 분리
  - Saga 디자인 패턴
    - 사가는 각 서비스가 작업을 수행하고 이벤트 또는 메시지를 통해 다음 단계를 시작하는 로컬 트랜잭션의 시퀀스이다.
    - 시퀀스의 단계가 실패하면 사가는 보상 트랜잭션을 실행하여 완료된 단계를 실행 취소하고 데이터 일관성을 유지한다.
    - 보상 트랜잭션과 피벗 트랜잭션으로, 실패 트랜잭션을 취소하고 성공 트랜잭션이 취소되지 않도록 관리한다.
    - Saga 패턴의 구현 방법은 일반적으로 크레오그래피와 오케스트레이션 두 가지가 존재한다.
      ![image](https://github.com/user-attachments/assets/cc56afb3-6951-443c-a101-4684770cfb2f)

  - Choreography(크레오그래피) 패턴
    - 이벤트 기반으로 트랜잭션 흐름을 조율. 각 서비스가 자체 이벤트를 처리하여 트랜잭션 실행.
      1. 각 서비스는 자신의 로컬 트랜잭션을 실행하고, 작업 완료 후 이벤트를 발행.
      2. 다른 서비스는 해당 이벤트를 구독하여 자신의 작업을 실행.
    ![image](https://github.com/user-attachments/assets/954cdd4e-eac9-40b8-be9e-b619baaab235)

    - 장점과 단점
      1. 일반적으로 많이 쓰이는 방식이다.
      2. 이벤트에 따라 작업이 연속적으로 실행되는 개념으로, 관심사 분리(책임 분리)가 확실하다.
      3. 서비스가 독립성이 높다. 
      4. 이벤트 실패에 따른 복구가 복잡하다.
  - Orchestration(오케스트레이션) 패턴
    - 중앙 조정자가 트랜잭션 흐름을 제어하여 실행 순서를 결정.
    - Saga 오케스트레이터는 단계를 인식하고 필요한 순서대로 실행한다.<br>
      T3 단계가 실패하면(결제 실패) 오케스트레이터는 보정 트랜잭션 C1과 C2를 실행하여 데이터를 초기 상태로 복원한다.
    ![image](https://github.com/user-attachments/assets/d789b3f1-a6ca-480d-8b37-2700cab1ee56)

    - 장점과 단점
      1. 결국 한 곳에서 관리하기 때문에 오류 관리가 쉽다.
      2. 중앙 집중적인 개념으로, 관심사 분리(책임 분리)가 모호하다.
      3. 중앙의 조정자가 시스템 병목이 될 수 있다.

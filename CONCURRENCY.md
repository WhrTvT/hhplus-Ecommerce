# 데이터베이스 동시성 문제 보고서

## 개요

데이터베이스에서 동시성 문제는 `여러 사용자`가 `동시에` 데이터에 접근하거나 수정할 때 발생할 수 있는 문제입니다.
이는 특히 트랜잭션을 처리하는 시스템에서 중요한 이슈로, 적절한 처리가 이루어지지 않으면 데이터 **일관성**, **무결성** 및 성능에 심각한 영향을 미칠 수 있습니다.

## 동시성 문제의 이해

1. 동시성 문제는 보통 아래의 경우에서 문제가 심각해집니다.<br>
    - 데이터의 수정 작업이 `다량의 요청`에 의해 `자주 변경`되는 경우
    - 다수의 작업이 데이터 수정에 관여해 자주 변경되는 경우

2. 트랜잭션 격리 수준에 따라 **Dirty Read, Non-Repetable Read, Phantom Read**의 문제점이 발생할 수 있습니다.<br>
   ![image](https://github.com/user-attachments/assets/6f605340-80a2-4260-b06e-ec305f4ac8cd)
    - **Read Uncommitted**: 다른 트랜잭션의 커밋되지 않은 데이터를 읽을 수 있습니다. 더티 읽기 문제가 발생할 수 있습니다.
    - **Read Committed** (Oracle Default): 커밋된 데이터만 읽을 수 있습니다. 더티 읽기 문제는 방지하지만, 비 반복 읽기 문제는 발생할 수 있습니다.
    - **Repeatable Read** (MySQL Default): 트랜잭션 내에서 읽은 데이터는 변경되지 않도록 보장합니다. 비 반복 읽기 문제를 해결할 수 있지만, 팬텀 읽기 문제는 해결되지 않습니다.
    - **Serializable**: 가장 높은 격리 수준으로, 트랜잭션이 실행되는 동안 다른 트랜잭션이 데이터에 접근할 수 없도록 보장합니다. 이로 인해 성능이 저하될 수 있지만, 모든 동시성 문제가 해결됩니다.

## 동시성 문제의 종류

### 1. Dirty Read - Uncommitted Dependency
Dirty Read는 한 트랜잭션이 다른 트랜잭션의 변경 사항을 커밋 전에 읽는 경우 발생합니다.<br>
이때 읽은 데이터가 나중에 롤백될 수 있어 일관성 문제가 발생합니다.

**예시:**
![image](https://github.com/user-attachments/assets/9989ed93-8065-428e-8059-f17c96d5741a)
- `Transaction 1`이 데이터를 수정하고 커밋하지 않았을 때, `Trasaction 2`가 이를 읽고 사용하는 경우.<br>
  만약 `Transaction 1`이 롤백되면 `Transaction 2`는 잘못된 데이터를 기반으로 작업을 진행하게 됩니다.

### 2. Non-repeatable Read - Inconsistency
Non-repeatable Read는 동일한 트랜잭션 내에서 같은 데이터를 두 번 읽었을 때, 두 번의 읽기 결과가 달라지는 문제입니다.<br>
이는 다른 트랜잭션이 데이터를 수정한 경우 발생합니다.

**예시:**
![image](https://github.com/user-attachments/assets/08bb5ebb-28ba-4e8b-be6e-bb45283a0552)
- `Transaction 1`이 특정 데이터를 읽고, 같은 데이터를 다시 읽는 사이에 `Transaction 2`가 데이터를 수정한 경우.<br>
  이때 `Transaction 1`의 READ 데이터는 처음 데이터와 결과가 다르게 나타납니다.

### 3. Phantom Read
Phantom Read는 트랜잭션이 데이터를 읽을 때, 다른 트랜잭션에서 새롭게 데이터를 추가하거나 삭제하는 경우 발생합니다.<br>
여러 개의 데이터를 조회할 떄 발생한다는 점에서 비 반복 읽기와는 다른 현상입니다.

**예시:**
![image](https://github.com/user-attachments/assets/2694cbbf-2a6f-43b4-822e-768cad73995d)
- `Transaction 1`이 특정 조건을 만족하는 데이터를 읽고나서 `Transaction 2`가 데이터를 추가한 경우.<br>
  `Transaction 1`가 다시 데이터를 읽을 때 결과가 달라지게 됩니다.

### 4. Dirty Write - Lost Update
Dirty Write는 두 개 이상의 트랜잭션이 동일한 데이터를 동시에 수정하려고 할 때 발생합니다.<br>
한 트랜잭션의 수정 내용이 다른 트랜잭션에 의해 덮어씌워져, 한 트랜잭션의 업데이트가 손실되는 문제입니다.

**예시:**
- `Transaction 1`과 `Transaction 2`가 동일한 데이터를 읽고 수정한 경우.<br>
  `Transaction 1`이 커밋되었을 때 `Transaction 2`가 커밋되면 `Transaction 1`의 변경 내용이 사라지게 됩니다.

## 동시성 문제의 해결

### 1. DB Lock
DB Lock은 트랜잭션 처리의 순차성을 보장하기 위해 DB에서 지원하는 기법입니다.<br>
데이터에 대한 접근을 제어하여 동시에 여러 트랜잭션이 같은 데이터를 수정하는 것을 방지할 수 있습니다.

- Lock의 종류
    - **Shared lock (읽기 잠금)**: 데이터를 사용 중일 경우, 다른 트랜잭션에서 데이터를 읽는 것은 가능하지만 변경은 불가능
    - **Exclusive lock (배타적 잠금)**: 데이터를 사용 중일 경우, 해당 트랜잭션이 완료될 때 까지 다른 트랜젹션은 데이터를 읽거나 변경이 불가능
      ![image](https://github.com/user-attachments/assets/c245f9e6-2908-4971-a8ff-efa47e9cabfb)

- Lock을 이용한 동시성 제어
    - **Optimistic Locking (낙관적 잠금)**: 트랜잭션이 데이터를 수정할 때 다른 트랜잭션이 동시에 수정하지 않았다는 가정 하에 데이터를 수정하며, 충돌이 발생하면 트랜잭션을 롤백 후 다시시도
      ![image](https://github.com/user-attachments/assets/32b5a0b7-fd89-4fa9-8310-a4eeacd62e14)
        1. 충돌 빈도가 `적을 경우` 권장
        2. 잦은 경합으로 retry가 많아지면 그만큼 성능 저하

    - **Pessimistic Locking (비관적 잠금)**: 트랜잭션이 데이터를 수정하기 전에 해당 데이터에 잠금을 설정하고, 다른 트랜잭션은 잠금이 해제될 때까지 대기
      ![image](https://github.com/user-attachments/assets/55415e76-0b9e-4b49-998e-2a3feb347955)
        1. 충돌 빈도가 `많을 경우` 권장
        2. 트래픽이 몰리거나 테이블에 Lock을 걸면서 작업하는 트랜잭션의 경우 데드락 유발 가능성

### 2. Redis - Distributed Lock
Redis는 분산 시스템에서 서로 다른 서버 인스턴스에 대한 일관된 락을 제공하기 위한 장치입니다.
분산락의 핵심은 `분산된 서버/클러스터` 간에도 Lock 을 보장하는 것으로, key-value 기반의 원자성을 이용한 Redis 를 통해 DB 부하를 최소화하는 Lock을 설계합니다.
- Redis를 활용한 분산락의 대표적인 세가지 방식은 아래와 같습니다.
    - `simple Lock` : key 선점에 의한 lock 획득 실패 시, 비즈니스 로직을 수행하지 않음
    - `spin Lock` : lock 획득 실패 시, 일정 시간/횟수 동안 Lock 획득을 재시도
    - `Pub/Sub` :  redis pub/sub 구독 기능을 이용해 lock을 제어

- Redis에서 Lecttuce와 Redisson을 이용하여 분산락을 구현할 수 있습니다.
    - `Lettuce`
        1. Lettuce는 가볍고 최소한의 의존성만을 가지며, 단순한 Redis 클라이언트로 사용 가능
        2. spin Lock 방식을 사용하기 때문에 Lock 해제에 대한 주기적인 retry로, 부하가 발생할 수 있음.
    - `Redisson`
        1. 분산 객체, 서비스 및 Redis 기반의 데이터 구조를 지원하여 사용자가 쉽게 사용할 수 있음.
        2. RBucket, RMap, RList 등의 고수준 API를 제공하여 개발자가 쉽게 사용할 수 있음.
        3. Pub/Sub 방식을 사용하기 떄문에 상대적으로 부하가 적음.
        4. 다른 Redis 클라이언트에 비해 기능이 많아 의존성 크기가 큼.

## 이커머스 서비스에서의 동시성 이슈

### 1. 상품 재고 차감
- 현재 로직상, 주문이 완료되면 재고가 차감되기 떄문에 재고 복원에 대한 동시성은 존재하지 않음.
- 재고 차감 시, 남은 재고보다 더 많이 차감될 수 있는 이슈가 존재함.

### 2. 유저 잔액 충전
- 잔액 충전이 동시에 요청될 경우 일부 요청이 실패할 수 있는 이슈가 존재함.

### 3. 선착순 쿠폰 발급/사용
- 여러 유저가 동시에 쿠폰을 발급할 경우, 쿠폰 재고를 초과한 쿠폰을 발급할 수 있는 이슈가 존재함.
- 정책상, 주문당 쿠폰은 1개만 사용 가능하지만 쿠폰 사용 요청이 동시에 들어온다면 복수 개의 쿠폰이 사용될 수 있는 이슈가 존재함.

### 4. 주문 결제 진행
- 한 개의 주문 건에 대한 결제가 여러 번 진행될 수 있는 이슈가 존재함.

## 결론
이번 이커머스 서비스에서는 DB Lock을 이용한 동시성 제어를 진행합니다.
서비스의 크기가 크지 않다는 점, 아키텍처(목표)가 확장에 유의하여 설계되지 않았다는 점에서 Redis를 사용하기에는 배보다 배꼽이 더 크다고 판단했습니다.
이에, 각 서비스(상품 재고 차감, 유저 잔액 충전/사용, 선착순 쿠폰 발급/사용)에 트랜잭션과 비관적 락을 사용한 동시성 제어를 구현하였고, 그에 따른 통합 테스트를 작성하였습니다. 

---
## 결론에 대한 회고 - 2025.03.18
- 기존에는 서비스의 크기가 크지않고 아키텍처 자체가 Redis를 사용하는 데에 적합하지 않다고 생각했었습니다.
- 하지만 프로젝트를 완료하고, 회고 과정에서 'Redis를 사용하는 것이 좋았을 것 같다'라고 생각을 바꿨습니다.
- 이유는 아래와 같습니다.
    1. 쿠폰 발급 API(비관 락)에 부하테스트를 진행한 결과, 500VU에 대한 원활한 처리가 이루어지지 않았습니다. [[STEP-11] 대용량 트래픽 & 데이터 처리](https://github.com/WhrTvT/hhplus-Ecommerce/pull/35) 참고
    2. 쿠폰 발급에 대한 선착순이 보장되지 않고, DB와의 통신으로 인해 대기열에 대한 처리가 느립니다.
- 만약, Redis를 사용했다면 쿠폰의 재고를 Redis에서 처리하고 Set/List로 대기열에 대한 처리가 보장되었을 것 입니다.
- 추가로 잔액 충전과 결제의 충돌을 고려해서 비관적 락을 사용했지만, 실제로 충돌이 빈번하지 않을 것이라 예상됩니다.(불필요한 커넥션 대기 유발)
